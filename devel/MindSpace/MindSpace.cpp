#include "MindSpace.h"

#include <QUuid>
#include <QStringList>

namespace MindSpace
{

/* Our static hash containers for UUID->Node/Link types */
QHash<QString,MNodeType> MindSpace::MNodeType::s_nodeTypes;
QHash<QString,MLinkType> MindSpace::MLinkType::s_linkTypes;
/* Map node names to nodes */
QHash<QString,MNode*> MindSpace::MNode::s_nodes;
 
/* Our predefined types */
#define DefineNodeType(name, uuid) \
	static MNodeType MNodeType_##name ( #name, uuid); \
	const MNodeType & MNodeType:: name() { return MNodeType_##name; }

#define DefineLinkType(name, uuid) \
	static MLinkType MLinkType_##name ( #name, uuid); \
	const MLinkType & MLinkType:: name() { return MLinkType_##name; }

#define DefineLinkTypeList(name, uuid) \
	static MLinkType MLinkType_##name ( #name, uuid, true); \
	const MLinkType & MLinkType:: name() { return MLinkType_##name; }

// Generated by mindspace-types.pl from MindSpace.types
#include "mindspace-types.definitions"

QDebug operator<<(QDebug dbg, const MNodeType& type)
{
	dbg.nospace() << "MNodeType(name:" << type.name() <<", uuid:" << type.uuid() << ")";
	return dbg.space();
}

QDebug operator<<(QDebug dbg, const MLinkType& type)
{
	dbg.nospace() << "MLinkType(name:" << type.name() <<", uuid:" << type.uuid() << ")";
	return dbg.space();
}

QDebug operator<<(QDebug dbg, const MTruthValue& value)
{
	dbg.nospace() << "MTruthValue(type:" << (value.type() == MTruthValue::SimpleTruth ? "SimpleTruth" : "RangeTruth") <<", value:" << value.value()<<", rangeA:"<<value.rangeA()<<", rangeB:"<<value.rangeB() << ")";
	return dbg.space();
}

QDebug operator<<(QDebug dbg, const MNode* node) 
{
	dbg.nospace() << qPrintable(MNode::toSimpleString(node));
	return dbg.space();
}

QString MNode::toSimpleString(const MNode* node, bool renderLinks)
{
	if(!node)
	{
		return "(NULL)";
	}
	else
	{
		QStringList out;
		out << QString("#%1(%2)").arg(node->content()).arg(node->type().name());
		if(renderLinks)
		{
			const QList<MLink*> & links = node->links();
			if(!links.isEmpty())
				out << "\n";
				
			foreach(MLink *link, links)
			{
				out << "\t" << link->toString(link, node) << "\n";
			}
		}
		return out.join("");
	
	}
}

QString MNode::toString(const MNode* node, bool renderLinks)
{
	if(!node)
		return "MNode(0x0)";
		
	QStringList out;
	out << "MNode(content:" << node->content() <<", type:\"" << node->type().name() <<"\", uuid:" << node->uuid() << ")";
	if(renderLinks)
	{
		const QList<MLink*> & links = node->links();
		if(!links.isEmpty())
			out << "\n";
			
		foreach(MLink *link, links)
		{
			out << "\t" << link->toString(link, node) << "\n";
		}
	}
	
	return out.join("");
}

QDebug operator<<(QDebug dbg, const MLink* link) 
{
	return dbg.space() << qPrintable(MLink::toString(link));
}

QString MLink::toString(const MLink *link, const MNode *from)
{
	if(!link)
		return "MLink(0x0)";
		
	if(from)
	{
		//type:" << type() <<", node1:" << node1() <<", node2:" << node2() << ", uuid:" << uuid() << "
		QStringList out = QStringList() << " +-- " << link->type().name();
		if(link->type().hasList())
		{
			if(link->node1() == from)
				out << " --> [ ";
			else
				out << " <-- " << MNode::toSimpleString(link->node1(), false) << " = [ ";
			QStringList sublist;
			foreach(MNode *node, link->arguments())
			 	sublist << MNode ::toSimpleString(node, false);
			 out << sublist.join(" , ") << " ]";
		}
		else
		{
			if(link->node1() == from)
				out << " --> " << MNode::toSimpleString(link->node2(), false);
			else
				out << " <-- " << MNode::toSimpleString(link->node1(), false);
		}
		
		double value = link->truthValue().value();
		if(value < 1.0)
		{
			out << " (Tv:" << QString::number(value) << ")";
		}
		
		return out.join("");
	}
	else
	{
		QStringList out = QStringList() << "type:\"" << link->type().name() <<"\", node1:" << MNode::toString(link->node1()) <<", node2:" << MNode::toString(link->node2()) << ", uuid:" << link->uuid();
		return "MLink(" + out.join("") + ")";
	}
}

/** Create an empty MNode with type set to MindSpace::ConceptNode and LTI/STI to 1.0 each */
MNode::MNode()
	: QObject()
	, m_type(MNodeType::ConceptNode())
	, m_content("")
	, m_longTermImportance(1.0)
	, m_shortTermImportance(1.0)
	, m_links()
{
	/* just to thwart gcc's warnings about MindSpace::staticMetaObject being unused */
	Q_UNUSED(MindSpace::staticMetaObject);
	
	createUuid();
}

MNode::~MNode()
{
	qDeleteAll(m_links);
}

/** Creates a new MNode with the given \a content and \a type (defaults to MindSpace::ConceptNode) */
MNode::MNode( const QString& content, MindSpace::MNodeType type )
	: QObject()
	, m_type(type)
	, m_content(content)
	, m_longTermImportance(1.0)
	, m_shortTermImportance(1.0)
	, m_links()
{
	createUuid();
	setContent(content);
}

/** \return the MNode* object for the given node name if the node exists. If the node does not exist, and type is NOT a null type (See MNodetype::isNull()), then it creates a new node and returns that node object. Returns 0 (null) in all other cases */
MNode *MNode::node(const QString& name, MindSpace::MNodeType type)
{
	if(s_nodes.contains(name))
		return s_nodes.value(name);
	if(!type.isNull())
		return new MNode(name, type);
	return 0;
}

/** Set the MNodeType of this node to \a type. \sa type */
void MNode::setType(MNodeType type) { m_type = type; }

/** Set the content of this node to \a content. \sa content */
void MNode::setContent(const QString& content)
{
	if(s_nodes.contains(m_content))
		s_nodes.remove(m_content);
	
	m_content = content; 
	s_nodes.insert(content, this);
}

/** Set the long term importance of this node to \a imp. \sa longTermImportance */
void MNode::setLongTermImportance(double imp) { m_longTermImportance = imp; }

/** Set the short term importance of this node to \a imp. \sa shortTermImportance */
void MNode::setShortTermImportance(double imp) { m_shortTermImportance = imp; }

/** Set the list of links for this node to \a links. \sa links */
void MNode::setLinks(const QList<MLink*>& links) { m_links = links; }

/** Add link \a link to the internal list of links. \a emits linkAdded */ 
void MNode::addLink(MLink *link)
{
	if(m_links.contains(link))
		return;
		
	m_links.append(link);
	emit linkAdded(link);
}

/** Remove link \a link from the internal list of links. \a emits linkRemoved */
void MNode::removeLink(MLink *link)
{
	if(m_links.removeAll(link) > 0)
		emit linkRemoved(link);
}

/** Creates a new UUID for this node only if no UUID already assigned. \sa uuid */
void MNode::createUuid()
{
	if(!m_uuid.isEmpty())
		return;
	m_uuid = QUuid::createUuid().toString();
}


/*******************/
/** Creates an empty (null) MLink with the predefined link type 'PartOfLink'. \sa isNull */
MLink::MLink()
	: QObject()
	, m_node1(0)
	, m_node2(0)
	, m_linkType(MLinkType::PartOfLink())
	, m_truthValue()
{
	createUuid();
}

/** Creates a new MLink from \a node1 to \a node2 with the givne \a linkType and \a truth value */
MLink::MLink(MNode* node1, MNode* node2, MLinkType linkType, MTruthValue truth)
	: QObject()
	, m_node1(node1)
	, m_node2(node2)
	, m_linkType(linkType)
	, m_truthValue(truth)
{
	createUuid();
	node1->addLink(this);
	node2->addLink(this);
}

/** Creates a new MLink from \a node1 to the \a argumentList with the givne \a linkType and \a truth value */
MLink::MLink(MNode* node1, QList<MNode*> argumentList, MLinkType linkType, MTruthValue truth)
	: QObject()
	, m_node1(node1)
	, m_node2(0)
	, m_args(argumentList)
	, m_linkType(linkType)
	, m_truthValue(truth)
{
	createUuid();
	node1->addLink(this);
	//node2->addLink(this);
	foreach(MNode *node, argumentList)
		node->addLink(this);
}

MLink::~MLink()
{
	if(m_node1)
		m_node1->removeLink(this);
	if(m_node2)
		m_node2->removeLink(this);
	foreach(MNode *node, m_args)
		node->removeLink(this);
}

/** \return true if BOTH node1() and node2() are NULL. \sa node1, node2 */
bool MLink::isNull()
{
	if(!m_node1 && !m_node2)
		return true;
	return false;
}

/** Set the MLinkType of this link to \a type. \sa type */
void MLink::setType(MindSpace::MLinkType type) { m_linkType = type; }
/** Set the first MNode of this link to \a node1. \sa node1 */ 
void MLink::setNode1(MindSpace::MNode* node1) { m_node1 = node1; }
/** Set the second MNode of this link to \a node2. \sa node2 */
void MLink::setNode2(MindSpace::MNode* node2) { m_node2 = node2; }
/** Set the MTruthValue of this link to \a value. \sa truthValue */
void MLink::setTruthValue(MindSpace::MTruthValue value) { m_truthValue = value; }
/** Set the list of argument nodes to \a arguments. \sa arguments */
void MLink::setArguments(QList<MNode*> arguments) { m_args = arguments; }

/** Creates a new UUId for this link only if no UUId already assigned. \sa uuid */
void MLink::createUuid()
{
	if(!m_uuid.isEmpty())
		return;
	m_uuid = QUuid::createUuid().toString();
}


}; /* namespace MindSpace */
